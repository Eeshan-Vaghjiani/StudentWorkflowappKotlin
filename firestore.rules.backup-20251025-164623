rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    // Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }
    
    // Check if user owns the resource
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    // Check if a string is a valid Firebase Storage URL
    function isValidStorageUrl(url) {
      return url == null || url == '' || 
        url.matches('https://firebasestorage.googleapis.com/.*');
    }
    
    // Check if user is a member of a specific group
    function isGroupMember(groupId) {
      return request.auth.uid in get(/databases/$(database)/documents/groups/$(groupId)).data.memberIds;
    }
    
    // Check if user is a participant in a specific chat
    function isChatParticipant(chatId) {
      return request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }
    
    // Validate array size
    function isValidArraySize(arr, min, max) {
      return arr.size() >= min && arr.size() <= max;
    }
    
    // Validate string length
    function isValidStringLength(str, max) {
      return str == null || str.size() <= max;
    }
    
    // Check if timestamp is recent (within 5 minutes)
    function isRecentTimestamp(timestamp) {
      return timestamp > request.time.toMillis() - 300000 && 
             timestamp < request.time.toMillis() + 300000;
    }
    
    // ============================================
    // USERS COLLECTION
    // ============================================
    
    match /users/{userId} {
      // Any authenticated user can read user profiles (for search, chat, etc.)
      allow read: if isAuthenticated();
      
      // Users can create their own document with profile picture URL validation
      allow create: if isAuthenticated() && 
        isOwner(userId) &&
        isValidStorageUrl(request.resource.data.get('profileImageUrl', ''));
      
      // Users can update their own document with profile picture URL validation
      allow update: if isAuthenticated() && 
        isOwner(userId) &&
        isValidStorageUrl(request.resource.data.get('profileImageUrl', ''));
      
      // Users can delete their own document
      allow delete: if isAuthenticated() && isOwner(userId);
    }
    
    // ============================================
    // GROUPS COLLECTION
    // ============================================
    
    match /groups/{groupId} {
      // Allow reading public groups OR groups where user is a member
      // Supports queries with: .where('isPublic', '==', true) or .whereArrayContains("memberIds", userId)
      allow read: if isAuthenticated() && 
        (resource.data.get('isPublic', false) == true ||
         request.auth.uid in resource.data.memberIds);
      
      // Any authenticated user can create a group with validation
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.memberIds &&
        request.auth.uid == request.resource.data.owner &&
        // Enforce 1-100 member limit
        isValidArraySize(request.resource.data.memberIds, 1, 100);
      
      // Owner or members can update, with validation
      allow update: if isAuthenticated() && 
        (request.auth.uid == resource.data.owner ||
         request.auth.uid in resource.data.memberIds) &&
        // Ensure owner stays in memberIds
        request.resource.data.owner in request.resource.data.memberIds &&
        // Enforce 1-100 member limit
        isValidArraySize(request.resource.data.memberIds, 1, 100);
      
      // Only owner can delete groups
      allow delete: if isAuthenticated() && 
        request.auth.uid == resource.data.owner;
    }
    
    // ============================================
    // TASKS COLLECTION
    // ============================================
    
    match /tasks/{taskId} {
      // Users can read tasks they created OR are assigned to OR are members of the task's group
      // Supports queries with: .whereEqualTo("userId", userId) or .whereArrayContains("assignedTo", userId)
      allow read: if isAuthenticated() && 
        (request.auth.uid == resource.data.userId ||
         request.auth.uid in resource.data.get('assignedTo', []) ||
         (resource.data.get('groupId', null) != null && 
          isGroupMember(resource.data.groupId)));
      
      // Any authenticated user can create tasks with validation
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.userId &&
        // If groupId is set, user must be a member of that group
        (request.resource.data.get('groupId', null) == null ||
         isGroupMember(request.resource.data.groupId)) &&
        // Validate assignedTo array (1-50 users)
        isValidArraySize(request.resource.data.get('assignedTo', [request.auth.uid]), 1, 50) &&
        // Ensure creator is in assignedTo array
        request.auth.uid in request.resource.data.get('assignedTo', [request.auth.uid]);
      
      // Task creator or assigned users can update with validation
      allow update: if isAuthenticated() && 
        (request.auth.uid == resource.data.userId ||
         request.auth.uid in resource.data.get('assignedTo', [])) &&
        // If changing groupId, verify membership in new group
        (request.resource.data.get('groupId', null) == null ||
         isGroupMember(request.resource.data.groupId)) &&
        // Validate assignedTo array (1-50 users)
        isValidArraySize(request.resource.data.get('assignedTo', []), 1, 50);
      
      // Only task creator can delete
      allow delete: if isAuthenticated() && 
        request.auth.uid == resource.data.userId;
    }
    
    // ============================================
    // CHATS COLLECTION
    // ============================================
    
    match /chats/{chatId} {
      // Only participants can read chat metadata
      // Supports queries with: .whereArrayContains("participants", userId)
      allow read: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
      
      // Allow create if user is in the participants array with validation
      allow create: if isAuthenticated() && 
        request.auth.uid in request.resource.data.participants &&
        // Validate participant count based on chat type
        ((request.resource.data.type == 'DIRECT' && 
          request.resource.data.participants.size() == 2) ||
         (request.resource.data.type == 'GROUP' && 
          isValidArraySize(request.resource.data.participants, 2, 100)));
      
      // Only participants can update chat (for typing status, last message, etc.)
      // Prevent changing participants array (use separate operations)
      allow update: if isAuthenticated() && 
        request.auth.uid in resource.data.participants &&
        request.resource.data.participants == resource.data.participants;
      
      // Only participants can delete chat
      allow delete: if isAuthenticated() && 
        request.auth.uid in resource.data.participants;
      
      // Messages subcollection
      match /messages/{messageId} {
        // Only chat participants can read messages (checks parent chat document)
        allow read: if isAuthenticated() && 
          isChatParticipant(chatId);
        
        // Only chat participants can create messages with validation
        allow create: if isAuthenticated() && 
          isChatParticipant(chatId) &&
          request.auth.uid == request.resource.data.senderId &&
          // Validate message has content (at least one of text, imageUrl, or documentUrl)
          (request.resource.data.get('text', '').size() > 0 ||
           request.resource.data.get('imageUrl', null) != null ||
           request.resource.data.get('documentUrl', null) != null) &&
          // Validate text length (max 10,000 characters)
          isValidStringLength(request.resource.data.get('text', ''), 10000) &&
          // Validate URLs are from Firebase Storage
          isValidStorageUrl(request.resource.data.get('imageUrl', '')) &&
          isValidStorageUrl(request.resource.data.get('documentUrl', '')) &&
          // Validate timestamp is recent (within 5 minutes of server time)
          isRecentTimestamp(request.resource.data.timestamp);
        
        // Message sender can update their own messages (for editing)
        allow update: if isAuthenticated() && 
          request.auth.uid == resource.data.senderId &&
          isChatParticipant(chatId);
        
        // Only message sender can delete their own messages
        allow delete: if isAuthenticated() && 
          request.auth.uid == resource.data.senderId;
      }
    }
    
    // ============================================
    // TYPING STATUS SUBCOLLECTION
    // ============================================
    
    match /chats/{chatId}/typing_status/{userId} {
      // Read if user is a participant in the parent chat
      allow read: if isAuthenticated() && 
        isChatParticipant(chatId);
      
      // Write own typing status only, if participant
      allow write: if isAuthenticated() && 
        request.auth.uid == userId &&
        isChatParticipant(chatId);
    }
    
    // ============================================
    // NOTIFICATIONS COLLECTION
    // ============================================
    // NOTE: Notifications are created server-side via Cloud Functions using the Admin SDK.
    // Client applications cannot create notifications directly to prevent spam and abuse.
    // Users can only mark their own notifications as read or delete them.
    
    match /notifications/{notificationId} {
      // Users can only read their own notifications
      allow read: if isAuthenticated() && 
        isOwner(resource.data.userId);
      
      // Block client-side notification creation
      // Cloud Functions use the Admin SDK which bypasses these rules
      allow create: if false;
      
      // Users can only update their own notifications
      // Restrict updates to only the 'read' field to prevent tampering
      allow update: if isAuthenticated() && 
        isOwner(resource.data.userId) &&
        // Only allow updating the 'read' field
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['read']);
      
      // Users can delete their own notifications
      allow delete: if isAuthenticated() && 
        isOwner(resource.data.userId);
    }
    
    // ============================================
    // GROUP ACTIVITIES COLLECTION
    // ============================================
    
    match /group_activities/{activityId} {
      // Read if user is in denormalized memberIds OR is a member of the group
      // Supports both denormalized and non-denormalized access patterns
      // Supports queries with: .where('groupId', '==', groupId) for group members
      allow read: if isAuthenticated() && 
        (request.auth.uid in resource.data.get('memberIds', []) ||
         isGroupMember(resource.data.groupId));
      
      // Create if user is a group member
      // Validates group membership and ensures user is in memberIds if denormalized
      allow create: if isAuthenticated() && 
        isGroupMember(request.resource.data.groupId) &&
        request.auth.uid in request.resource.data.get('memberIds', []);
      
      // Only activity creator can update their activities
      allow update: if isAuthenticated() && 
        request.auth.uid == resource.data.userId;
      
      // Only activity creator can delete activities
      allow delete: if isAuthenticated() && 
        request.auth.uid == resource.data.userId;
    }
  }
}